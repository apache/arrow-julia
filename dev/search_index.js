var documenterSearchIndex = {"docs":
[{"location":"manual/#User-Manual","page":"User Manual","title":"User Manual","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The goal of this documentation is to provide a brief introduction to the arrow data format, then provide a walk-through of the functionality provided in the Arrow.jl Julia package, with an aim to expose a little of the machinery \"under the hood\" to help explain how things work and how that influences real-world use-cases for the arrow data format.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The best place to learn about the Apache arrow project is the website itself, specifically the data format specification. Put briefly, the arrow project provides a formal speficiation for how columnar, \"table\" data can be laid out efficiently in memory to standardize and maximize the ability to share data across languages/platforms. In the current apache/arrow GitHub repository, language implementations exist for C++, Java, Go, Javascript, Rust, to name a few. Other database vendors and data processing frameworks/applications have also built support for the arrow format, allowing for a wide breadth of possibility for applications to \"speak the data language\" of arrow.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The Arrow.jl Julia package is another implementation, allowing the ability to both read and write data in the arrow format. As a data format, arrow specifies an exact memory layout to be used for columnar table data, and as such, \"reading\" involves custom Julia objects (Arrow.Table and Arrow.Stream), which read the metadata of an \"arrow memory blob\", then wrap the array data contained therein, having learned the type and size, amongst other properties, from the metadata. Let's take a closer look at what this \"reading\" of arrow memory really means/looks like.","category":"page"},{"location":"manual/#Reading-arrow-data","page":"User Manual","title":"Reading arrow data","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"After installing the Arrow.jl Julia package (via ] add Arrow), and if you have some arrow data, let's say a file named data.arrow generated from the pyarrow library (a Python library for interfacing with arrow data), you can then read that arrow data into a Julia session by doing:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"using Arrow\n\ntable = Arrow.Table(\"data.arrow\")","category":"page"},{"location":"manual/#Arrow.Table","page":"User Manual","title":"Arrow.Table","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The type of table in this example will be an Arrow.Table. When \"reading\" the arrow data, Arrow.Table first \"mmapped\" the data.arrow file, which is an important technique for dealing with data larger than available RAM on a system. By \"mmapping\" a file, the OS doesn't actually load the entire file contents into RAM at the same time, but file contents are \"swapped\" into RAM as different regions of a file are requested. Once \"mmapped\", Arrow.Table then inspected the metadata in the file to determine the number of columns, their names and types, at which byte offset each column begins in the file data, and even how many \"batches\" are included in this file (arrow tables may be partitioned into one ore more \"record batches\" each containing portions of the data). Armed with all the appropriate metadata, Arrow.Table then created custom array objects (ArrowVector), which act as \"views\" into the raw arrow memory bytes. This is a significant point in that no extra memory is allocated for \"data\" when reading arrow data. This is in contrast to if we wanted to read the data of a csv file as columns into Julia structures; we would need to allocate those array structures ourselves, then parse the file, \"filling in\" each element of the array with the data we parsed from the file. Arrow data, on the other hand, is already laid out in memory or on disk in a binary format, and as long as we have the metadata to interpret the raw bytes, we can figure out whether to treat those bytes as a Vector{Float64}, etc. A sample of the kinds of arrow array types you might see when deserializing arrow data, include:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Arrow.Primitive: the most common array type for simple, fixed-size elements like integers, floats, time types, and decimals\nArrow.List: an array type where its own elements are also arrays of some kind, like string columns, where each element can be thought of as an array of characters\nArrow.FixedSizeList: similar to the List type, but where each array element has a fixed number of elements itself; you can think of this like a Vector{NTuple{N, T}}, where N is the fixed-size width\nArrow.Map: an array type where each element is like a Julia Dict; a list of key value pairs like a Vector{Dict}\nArrow.Struct: an array type where each element is an instance of a custom struct, i.e. an ordered collection of named & typed fields, kind of like a Vector{NamedTuple}\nArrow.DenseUnion: an array type where elements may be of several different types, stored compactly; can be thought of like Vector{Union{A, B}}\nArrow.SparseUnion: another array type where elements may be of several different types, but stored as if made up of identically lengthed child arrays for each possible type (less memory efficient than DenseUnion)\nArrow.DictEncoded: a special array type where values are \"dictionary encoded\", meaning the list of unique, possible values for an array are stored internally in an \"encoding pool\", whereas each stored element of the array is just an integer \"code\" to index into the encoding pool for the actual value.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"And while these custom array types do subtype AbstractArray, there is only limited support for setindex!. Remember, these arrays are \"views\" into the raw arrow bytes, so for array types other than Arrow.Primitive, it gets pretty tricky to allow manipulating those raw arrow bytes. Nevetheless, it's as simple as calling copy(x) where x is any ArrowVector type, and a normal Julia Vector type will be fully materialized (which would then allow mutating/manipulating values).","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"So, what can you do with an Arrow.Table full of data? Quite a bit actually!","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Because Arrow.Table implements the Tables.jl interface, it opens up a world of integrations for using arrow data. A few examples include:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"df = DataFrame(Arrow.Table(file)): Build a DataFrame, using the arrow vectors themselves; this allows utilizing a host of DataFrames.jl functionality directly on arrow data; grouping, joining, selecting, etc.\nTables.datavaluerows(Arrow.Table(file)) |> @map(...) |> @filter(...) |> DataFrame: use Query.jl's row-processing utilities to map, group, filter, mutate, etc. directly over arrow data.\nArrow.Table(file) |> SQLite.load!(db, \"arrow_table\"): load arrow data directly into an sqlite database/table, where sql queries can be executed on the data\nArrow.Table(file) |> CSV.write(\"arrow.csv\"): write arrow data out to a csv file","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"A full list of Julia packages leveraging the Tables.jl inteface can be found here.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Apart from letting other packages have all the fun, an Arrow.Table itself can be plenty useful. For example, with tbl = Arrow.Table(file):","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"tbl[1]: retrieve the first column via indexing; the number of columns can be queried via length(tbl)\ntbl[:col1] or tbl.col1: retrieve the column named col1, either via indexing with the column name given as a Symbol, or via \"dot-access\"\nfor col in tbl: iterate through columns in the table\nAbstractDict methods like haskey(tbl, :col1), get(tbl, :col1, nothing), keys(tbl), or values(tbl)","category":"page"},{"location":"manual/#Arrow-types","page":"User Manual","title":"Arrow types","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"In the arrow data format, specific logical types are supported, a list of which can be found here. These include booleans, integers of various bit widths, floats, decimals, time types, and binary/string. While most of these map naturally to types builtin to Julia itself, there are a few cases where the definitions are slightly different, and in these cases, by default, they are converted to more \"friendly\" Julia types (this auto conversion can be avoided by passing convert=false to Arrow.Table, like Arrow.Table(file; convert=false)). Examples of arrow to julia type mappings include:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Date, Time, Timestamp, and Duration all have natural Julia defintions in Dates.Date, Dates.Time, TimeZones.ZonedDateTime, and Dates.Period subtypes, respectively. \nChar and Symbol Julia types are mapped to arrow string types, with additional metadata of the original Julia type; this allows deserializing directly to Char and Symbol in Julia, while other language implementations will see these columns as just strings\nDecimal128 and Decimal256 have no corresponding builtin Julia types, so they're deserialized using a compatible type definition in Arrow.jl itself: Arrow.Decimal","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Note that when convert=false is passed, data will be returned in Arrow.jl-defined types that exactly match the arrow definitions of those types; the authoritative source for how each type represents its data can be found in the arrow Schema.fbs file.","category":"page"},{"location":"manual/#Custom-types","page":"User Manual","title":"Custom types","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"To support writing your custom Julia struct, Arrow.jl utilizes the format's mechanism for \"extension types\" by storing the Julia type name in the field metadata. To \"hook in\" to this machinery, custom types can just call Arrow.ArrowTypes.registertype!(T, T), where T is the custom struct type. For example:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"using Arrow\n\nstruct Person\n    id::Int\n    name::String\nend\n\nArrow.ArrowTypes.registertype!(Person, Person)\n\ntable = (col1=[Person(1, \"Bob\"), Person(2, \"Jane\")],)\nio = IOBuffer()\nArrow.write(io, table)\nseekstart(io)\ntable2 = Arrow.Table(io)","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"In this example, we're writing our table, which is a NamedTuple with one column named col1, which has two elements which are instances of our custom Person struct. We call Arrow.Arrowtypes.registertype! so that Arrow.jl knows how to serialize our Person struct. We then read the table back in using Arrow.Table and the table we get back will be an Arrow.Table, with a single Arrow.Struct column with element type Person.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Note that without calling Arrow.Arrowtypes.registertype!, we may get into a weird limbo state where we've written our table with Person structs out as a table, but when reading back in, Arrow.jl doesn't know what a Person is; deserialization won't fail, but we'll just get a Namedtuple{(:id, :name), Tuple{Int, String}} back instead of Person.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"warning: Warning\nIf Arrow.ArrowTypes.registertype! is called in a downstream package, e.g. to register a custom type defined in that package, it must be called from the __init__ function of the package's top-level module (see the Julia docs for more on __init__ functions). Otherwise, the type will only be registered during the precompilation phase, but that state will be lost afterwards (and in particular, the type will not be registered when the package is loaded).","category":"page"},{"location":"manual/#Arrow.Stream","page":"User Manual","title":"Arrow.Stream","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"In addition to Arrow.Table, the Arrow.jl package also provides Arrow.Stream for processing arrow data. While Arrow.Table will iterate all record batches in an arrow file/stream, concatenating columns, Arrow.Stream provides a way to iterate through record batches, one at a time. Each iteration yields an Arrow.Table instance, with columns/data for a single record batch. This allows, if so desired, \"batch processing\" of arrow data, one record batch at a time, instead of creating a single long table via Arrow.Table.","category":"page"},{"location":"manual/#Table-and-column-metadata","page":"User Manual","title":"Table and column metadata","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The arrow format allows attaching arbitrary metadata in the form of a Dict{String, String} to tables and individual columns. The Arrow.jl package supports retrieving serialized metadata by calling Arrow.getmetadata(table) or Arrow.getmetadata(column).","category":"page"},{"location":"manual/#Writing-arrow-data","page":"User Manual","title":"Writing arrow data","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Ok, so that's a pretty good rundown of reading arrow data, but how do you produce arrow data? Enter Arrow.write.","category":"page"},{"location":"manual/#Arrow.write","page":"User Manual","title":"Arrow.write","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"With Arrow.write, you provide either an io::IO argument or file::String to write the arrow data to, as well as a Tables.jl-compatible source that contains the data to be written.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"What are some examples of Tables.jl-compatible sources? A few examples include:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Arrow.write(io, df::DataFrame): A DataFrame is a collection of indexable columns\nArrow.write(io, CSV.File(file)): read data from a csv file and write out to arrow format\nArrow.write(io, DBInterface.execute(db, sql_query)): Execute an SQL query against a database via the DBInterface.jl interface, and write the query resultset out directly in the arrow format. Packages that implement DBInterface include SQLite.jl, MySQL.jl, and ODBC.jl. \ndf |> @map(...) |> Arrow.write(io): Write the results of a Query.jl chain of operations directly out as arrow data\njsontable(json) |> Arrow.write(io): Treat a json array of objects or object of arrays as a \"table\" and write it out as arrow data using the JSONTables.jl package\nArrow.write(io, (col1=data1, col2=data2, ...)): a NamedTuple of AbstractVectors or an AbstractVector of NamedTuples are both considered tables by default, so they can be quickly constructed for easy writing of arrow data if you already have columns of data","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"And these are just a few examples of the numerous integrations.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"In addition to just writing out a single \"table\" of data as a single arrow record batch, Arrow.write also supports writing out multiple record batches when the input supports the Tables.partitions functionality. One immediate, though perhaps not incredibly useful example, is Arrow.Stream. Arrow.Stream implements Tables.partitions in that it iterates \"tables\" (specifically Arrow.Table), and as such, Arrow.write will iterate an Arrow.Stream, and write out each Arrow.Table as a separate record batch. Another important point for why this example works is because an Arrow.Stream iterates Arrow.Tables that all have the same schema. This is important because when writing arrow data, a \"schema\" message is always written first, with all subsequent record batches written with data matching the initial schema.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"In addition to inputs that support Tables.partitions, note that the Tables.jl itself provides the Tables.partitioner function, which allows providing your own separate instances of similarly-schema-ed tables as \"partitions\", like:","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"# treat 2 separate NamedTuples of vectors with same schema as 1 table, 2 partitions\ntbl_parts = Tables.partitioner([(col1=data1, col2=data2), (col1=data3, col2=data4)])\nArrow.write(io, tbl_parts)\n\n# treat an array of csv files with same schema where each file is a partition\n# in this form, a function `CSV.File` is applied to each element of 2nd argument\ncsv_parts = Tables.partitioner(CSV.File, csv_files)\nArrow.write(io, csv_parts)","category":"page"},{"location":"manual/#Multithreaded-writing","page":"User Manual","title":"Multithreaded writing","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"By default, Arrow.write will use multiple threads to write multiple record batches simultaneously (e.g. if julia is started with julia -t 8 or the JULIA_NUM_THREADS environment variable is set).","category":"page"},{"location":"manual/#Compression","page":"User Manual","title":"Compression","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Compression is supported when writing via the compress keyword argument. Possible values include :lz4, :zstd, or your own initialized LZ4FrameCompressor or ZstdCompressor objects; will cause all buffers in each record batch to use the respective compression encoding or compressor.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Arrow]\nOrder   = [:type, :function]","category":"page"},{"location":"reference/#Arrow.ArrowVector","page":"API Reference","title":"Arrow.ArrowVector","text":"Arrow.ArrowVector\n\nAn abstract type that subtypes AbstractVector. Each specific arrow array type subtypes ArrowVector. See BoolVector, Primitive, List, Map, FixedSizeList, Struct, DenseUnion, SparseUnion, and DictEncoded for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.BoolVector","page":"API Reference","title":"Arrow.BoolVector","text":"Arrow.BoolVector\n\nA bit-packed array type, similar to ValidityBitmap, but which holds boolean values, true or false.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.Compressed","page":"API Reference","title":"Arrow.Compressed","text":"Arrow.Compressed\n\nRepresents the compressed version of an ArrowVector. Holds a reference to the original column. May have Compressed children for nested array types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.DenseUnion","page":"API Reference","title":"Arrow.DenseUnion","text":"Arrow.DenseUnion\n\nAn ArrowVector where the type of each element is one of a fixed set of types, meaning its eltype is like a julia Union{type1, type2, ...}. An Arrow.DenseUnion, in comparison to Arrow.SparseUnion, stores elements in a set of arrays, one array per possible type, and an \"offsets\" array, where each offset element is the index into one of the typed arrays. This allows a sort of \"compression\", where no extra space is used/allocated to store all the elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.DictEncode","page":"API Reference","title":"Arrow.DictEncode","text":"Arrow.DictEncode(::AbstractVector, id::Integer=nothing)\n\nSignals that a column/array should be dictionary encoded when serialized to the arrow streaming/file format. An optional id number may be provided to signal that multiple columns should use the same pool when being dictionary encoded.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.DictEncoded","page":"API Reference","title":"Arrow.DictEncoded","text":"Arrow.DictEncoded\n\nA dictionary encoded array type (similar to a PooledArray). Behaves just like a normal array in most respects; internally, possible values are stored in the encoding::DictEncoding field, while the indices::Vector{<:Integer} field holds the \"codes\" of each element for indexing into the encoding pool. Any column/array can be dict encoding when serializing to the arrow format either by passing the dictencode=true keyword argument to Arrow.write (which causes all columns to be dict encoded), or wrapping individual columns/ arrays in Arrow.DictEncode(x).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.DictEncoding","page":"API Reference","title":"Arrow.DictEncoding","text":"Arrow.DictEncoding\n\nRepresents the \"pool\" of possible values for a DictEncoded array type. Whether the order of values is significant can be checked by looking at the isOrdered boolean field.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.FixedSizeList","page":"API Reference","title":"Arrow.FixedSizeList","text":"Arrow.FixedSizeList\n\nAn ArrowVector where each element is a \"fixed size\" list of some kind, like a NTuple{N, T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.List","page":"API Reference","title":"Arrow.List","text":"Arrow.List\n\nAn ArrowVector where each element is a variable sized list of some kind, like an AbstractVector or AbstractString.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.Map","page":"API Reference","title":"Arrow.Map","text":"Arrow.Map\n\nAn ArrowVector where each element is a \"map\" of some kind, like a Dict.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.Primitive","page":"API Reference","title":"Arrow.Primitive","text":"Arrow.Primitive\n\nAn ArrowVector where each element is a \"fixed size\" scalar of some kind, like an integer, float, decimal, or time type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.SparseUnion","page":"API Reference","title":"Arrow.SparseUnion","text":"Arrow.SparseUnion\n\nAn ArrowVector where the type of each element is one of a fixed set of types, meaning its eltype is like a julia Union{type1, type2, ...}. An Arrow.SparseUnion, in comparison to Arrow.DenseUnion, stores elements in a set of arrays, one array per possible type, and each typed array has the same length as the full array. This ends up with \"wasted\" space, since only one slot among the typed arrays is valid per full array element, but can allow for certain optimizations when each typed array has the same length.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.Stream","page":"API Reference","title":"Arrow.Stream","text":"Arrow.Stream(io::IO; convert::Bool=true)\nArrow.Stream(file::String; convert::Bool=true)\nArrow.Stream(bytes::Vector{UInt8}, pos=1, len=nothing; convert::Bool=true)\n\nStart reading an arrow formatted table, from:\n\nio, bytes will be read all at once via read(io)\nfile, bytes will be read via Mmap.mmap(file)\nbytes, a byte vector directly, optionally allowing specifying the starting byte position pos and len\n\nReads the initial schema message from the arrow stream/file, then returns an Arrow.Stream object which will iterate over record batch messages, producing an Arrow.Table on each iteration.\n\nBy iterating Arrow.Table, Arrow.Stream satisfies the Tables.partitions interface, and as such can be passed to Tables.jl-compatible sink functions.\n\nThis allows iterating over extremely large \"arrow tables\" in chunks represented as record batches.\n\nSupports the convert keyword argument which controls whether certain arrow primitive types will be lazily converted to more friendly Julia defaults; by default, convert=true.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.Struct","page":"API Reference","title":"Arrow.Struct","text":"Arrow.Struct\n\nAn ArrowVector where each element is a \"struct\" of some kind with ordered, named fields, like a NamedTuple{names, types} or regular julia struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.Table","page":"API Reference","title":"Arrow.Table","text":"Arrow.Table(io::IO; convert::Bool=true)\nArrow.Table(file::String; convert::Bool=true)\nArrow.Table(bytes::Vector{UInt8}, pos=1, len=nothing; convert::Bool=true)\n\nRead an arrow formatted table, from:\n\nio, bytes will be read all at once via read(io)\nfile, bytes will be read via Mmap.mmap(file)\nbytes, a byte vector directly, optionally allowing specifying the starting byte position pos and len\n\nReturns a Arrow.Table object that allows column access via table.col1, table[:col1], or table[1].\n\nNOTE: the columns in an Arrow.Table are views into the original arrow memory, and hence are not easily modifiable (with e.g. push!, append!, etc.). To mutate arrow columns, call copy(x) to materialize the arrow data as a normal Julia array.\n\nArrow.Table also satisfies the Tables.jl interface, and so can easily be materialied via any supporting sink function: e.g. DataFrame(Arrow.Table(file)), SQLite.load!(db, \"table\", Arrow.Table(file)), etc.\n\nSupports the convert keyword argument which controls whether certain arrow primitive types will be lazily converted to more friendly Julia defaults; by default, convert=true.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.ValidityBitmap","page":"API Reference","title":"Arrow.ValidityBitmap","text":"Arrow.ValidityBitmap\n\nA bit-packed array type where each bit corresponds to an element in an ArrowVector, indicating whether that element is \"valid\" (bit == 1), or not (bit == 0). Used to indicate element missingness (whether it's null).\n\nIf the null count of an array is zero, the ValidityBitmap will be \"emtpy\" and all elements are treated as \"valid\"/non-null.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Arrow.arrowtype","page":"API Reference","title":"Arrow.arrowtype","text":"Given a FlatBuffers.Builder and a Julia column or column eltype, Write the field.type flatbuffer definition of the eltype\n\n\n\n\n\n","category":"function"},{"location":"reference/#Arrow.getmetadata","page":"API Reference","title":"Arrow.getmetadata","text":"Arrow.getmetadata(x) => Dict{String, String}\n\nRetrieve any metadata (as a Dict{String, String}) attached to an object.\n\nMetadata may be attached to any object via Arrow.setmetadata!, or deserialized via the arrow format directly (the format allows attaching metadata to table, column, and other objects).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Arrow.juliaeltype","page":"API Reference","title":"Arrow.juliaeltype","text":"Given a flatbuffers metadata type definition (a Field instance from Schema.fbs), translate to the appropriate Julia storage eltype\n\n\n\n\n\n","category":"function"},{"location":"reference/#Arrow.setmetadata!-Tuple{Any,Dict{String,String}}","page":"API Reference","title":"Arrow.setmetadata!","text":"Arrow.setmetadata!(x, metadata::Dict{String, String})\n\nSet the metadata for any object, provided as a Dict{String, String}. Metadata attached to a table or column will be serialized when written as a stream or file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Arrow.write","page":"API Reference","title":"Arrow.write","text":"Arrow.write(io::IO, tbl)\nArrow.write(file::String, tbl)\ntbl |> Arrow.write(io_or_file)\n\nWrite any Tables.jl-compatible tbl out as arrow formatted data. Providing an io::IO argument will cause the data to be written to it in the \"streaming\" format, unless file=true keyword argument is passed. Providing a file::String argument will result in the \"file\" format being written.\n\nMultiple record batches will be written based on the number of Tables.partitions(tbl) that are provided; by default, this is just one for a given table, but some table sources support automatic partitioning. Note you can turn multiple table objects into partitions by doing Tables.partitioner([tbl1, tbl2, ...]), but note that each table must have the exact same Tables.Schema.\n\nBy default, Arrow.write will use multiple threads to write multiple record batches simultaneously (e.g. if julia is started with julia -t 8 or the JULIA_NUM_THREADS environment variable is set).\n\nSupported keyword arguments to Arrow.write include:\n\ncompress: possible values include :lz4, :zstd, or your own initialized LZ4FrameCompressor or ZstdCompressor objects; will cause all buffers in each record batch to use the respective compression encoding\nalignment::Int=8: specify the number of bytes to align buffers to when written in messages; strongly recommended to only use alignment values of 8 or 64 for modern memory cache line optimization\ndictencode::Bool=false: whether all columns should use dictionary encoding when being written; to dict encode specific columns, wrap the column/array in Arrow.DictEncode(col)\ndictencodenested::Bool=false: whether nested data type columns should also dict encode nested arrays/buffers; other language implementations may not support this\ndenseunions::Bool=true: whether Julia Vector{<:Union} arrays should be written using the dense union layout; passing false will result in the sparse union layout\nlargelists::Bool=false: causes list column types to be written with Int64 offset arrays; mainly for testing purposes; by default, Int64 offsets will be used only if needed\nfile::Bool=false: if a an io argument is being written to, passing file=true will cause the arrow file format to be written instead of just IPC streaming\n\n\n\n\n\n","category":"function"},{"location":"#Arrow.jl","page":"Home","title":"Arrow.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\", \"reference.md\"]\nDepth = 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"Arrow","category":"page"},{"location":"#Arrow","page":"Home","title":"Arrow","text":"Arrow.jl\n\nA pure Julia implementation of the apache arrow memory format specification.\n\nThis implementation supports the 1.0 version of the specification, including support for:\n\nAll primitive data types\nAll nested data types\nDictionary encodings, nested dictionary encodings, and messages\nExtension types\nStreaming, file, record batch, and replacement and isdelta dictionary messages\nBuffer compression/decompression via the standard LZ4 frame and Zstd formats\n\nIt currently doesn't include support for:\n\nTensors or sparse tensors\nFlight RPC\nC data interface\n\nThird-party data formats:\n\ncsv and parquet support via the existing CSV.jl and Parquet.jl packages\nOther Tables.jl-compatible packages automatically supported (DataFrames.jl, JSONTables.jl, JuliaDB.jl, SQLite.jl, MySQL.jl, JDBC.jl, ODBC.jl, XLSX.jl, etc.)\nNo current Julia packages support ORC or Avro data formats\n\nSee docs for official Arrow.jl API with the User Manual and reference docs for Arrow.Table, Arrow.write, and Arrow.Stream.\n\n\n\n\n\n","category":"module"}]
}
