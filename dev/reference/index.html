<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Arrow.jl</title><link rel="canonical" href="https://JuliaData.github.io/Arrow.jl/reference/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Arrow.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">User Manual</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/Arrow.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Arrow.ArrowVector" href="#Arrow.ArrowVector"><code>Arrow.ArrowVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.ArrowVector</code></pre><p>An abstract type that subtypes <code>AbstractVector</code>. Each specific arrow array type subtypes <code>ArrowVector</code>. See <a href="#Arrow.BoolVector"><code>BoolVector</code></a>, <a href="#Arrow.Primitive"><code>Primitive</code></a>, <a href="#Arrow.List"><code>List</code></a>, <a href="#Arrow.Map"><code>Map</code></a>, <a href="#Arrow.FixedSizeList"><code>FixedSizeList</code></a>, <a href="#Arrow.Struct"><code>Struct</code></a>, <a href="#Arrow.DenseUnion"><code>DenseUnion</code></a>, <a href="#Arrow.SparseUnion"><code>SparseUnion</code></a>, and <a href="#Arrow.DictEncoded"><code>DictEncoded</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/arraytypes.jl#LL17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.BoolVector" href="#Arrow.BoolVector"><code>Arrow.BoolVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.BoolVector</code></pre><p>A bit-packed array type, similar to <a href="#Arrow.ValidityBitmap"><code>ValidityBitmap</code></a>, but which holds boolean values, <code>true</code> or <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/bool.jl#LL17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.Compressed" href="#Arrow.Compressed"><code>Arrow.Compressed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.Compressed</code></pre><p>Represents the compressed version of an <a href="#Arrow.ArrowVector"><code>ArrowVector</code></a>. Holds a reference to the original column. May have <code>Compressed</code> children for nested array types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/compressed.jl#LL22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.DenseUnion" href="#Arrow.DenseUnion"><code>Arrow.DenseUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.DenseUnion</code></pre><p>An <code>ArrowVector</code> where the type of each element is one of a fixed set of types, meaning its eltype is like a julia <code>Union{type1, type2, ...}</code>. An <code>Arrow.DenseUnion</code>, in comparison to <code>Arrow.SparseUnion</code>, stores elements in a set of arrays, one array per possible type, and an &quot;offsets&quot; array, where each offset element is the index into one of the typed arrays. This allows a sort of &quot;compression&quot;, where no extra space is used/allocated to store all the elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/unions.jl#LL52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.DictEncode" href="#Arrow.DictEncode"><code>Arrow.DictEncode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.DictEncode(::AbstractVector, id::Integer=nothing)</code></pre><p>Signals that a column/array should be dictionary encoded when serialized to the arrow streaming/file format. An optional <code>id</code> number may be provided to signal that multiple columns should use the same pool when being dictionary encoded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/dictencoding.jl#LL56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.DictEncoded" href="#Arrow.DictEncoded"><code>Arrow.DictEncoded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.DictEncoded</code></pre><p>A dictionary encoded array type (similar to a <code>PooledArray</code>). Behaves just like a normal array in most respects; internally, possible values are stored in the <code>encoding::DictEncoding</code> field, while the <code>indices::Vector{&lt;:Integer}</code> field holds the &quot;codes&quot; of each element for indexing into the encoding pool. Any column/array can be dict encoding when serializing to the arrow format either by passing the <code>dictencode=true</code> keyword argument to <a href="#Arrow.write"><code>Arrow.write</code></a> (which causes <em>all</em> columns to be dict encoded), or wrapping individual columns/ arrays in <a href="#Arrow.DictEncode"><code>Arrow.DictEncode(x)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/dictencoding.jl#LL77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.DictEncoding" href="#Arrow.DictEncoding"><code>Arrow.DictEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.DictEncoding</code></pre><p>Represents the &quot;pool&quot; of possible values for a <a href="#Arrow.DictEncoded"><code>DictEncoded</code></a> array type. Whether the order of values is significant can be checked by looking at the <code>isOrdered</code> boolean field.</p><p>The <code>S</code> type parameter, while not tied directly to any field, is the signed integer &quot;index type&quot; of the parent DictEncoded. We keep track of this in the DictEncoding in order to validate the length of the pool doesn&#39;t exceed the index type limit. The general workflow of writing arrow data means the initial schema will typically be based off the data in the first record batch, and subsequent record batches need to match the same schema exactly. For example, if a non-first record batch dict encoded column were to cause a DictEncoding pool to overflow on unique values, a fatal error should be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/dictencoding.jl#LL17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.FixedSizeList" href="#Arrow.FixedSizeList"><code>Arrow.FixedSizeList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.FixedSizeList</code></pre><p>An <code>ArrowVector</code> where each element is a &quot;fixed size&quot; list of some kind, like a <code>NTuple{N, T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/fixedsizelist.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.List" href="#Arrow.List"><code>Arrow.List</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.List</code></pre><p>An <code>ArrowVector</code> where each element is a variable sized list of some kind, like an <code>AbstractVector</code> or <code>AbstractString</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/list.jl#LL31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.Map" href="#Arrow.Map"><code>Arrow.Map</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.Map</code></pre><p>An <code>ArrowVector</code> where each element is a &quot;map&quot; of some kind, like a <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/map.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.Primitive" href="#Arrow.Primitive"><code>Arrow.Primitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.Primitive</code></pre><p>An <code>ArrowVector</code> where each element is a &quot;fixed size&quot; scalar of some kind, like an integer, float, decimal, or time type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/primitive.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.SparseUnion" href="#Arrow.SparseUnion"><code>Arrow.SparseUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.SparseUnion</code></pre><p>An <code>ArrowVector</code> where the type of each element is one of a fixed set of types, meaning its eltype is like a julia <code>Union{type1, type2, ...}</code>. An <code>Arrow.SparseUnion</code>, in comparison to <code>Arrow.DenseUnion</code>, stores elements in a set of arrays, one array per possible type, and each typed array has the same length as the full array. This ends up with &quot;wasted&quot; space, since only one slot among the typed arrays is valid per full array element, but can allow for certain optimizations when each typed array has the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/unions.jl#LL176-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.Stream" href="#Arrow.Stream"><code>Arrow.Stream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.Stream(io::IO; convert::Bool=true)
Arrow.Stream(file::String; convert::Bool=true)
Arrow.Stream(bytes::Vector{UInt8}, pos=1, len=nothing; convert::Bool=true)</code></pre><p>Start reading an arrow formatted table, from:</p><ul><li><code>io</code>, bytes will be read all at once via <code>read(io)</code></li><li><code>file</code>, bytes will be read via <code>Mmap.mmap(file)</code></li><li><code>bytes</code>, a byte vector directly, optionally allowing specifying the starting byte position <code>pos</code> and <code>len</code></li></ul><p>Reads the initial schema message from the arrow stream/file, then returns an <code>Arrow.Stream</code> object which will iterate over record batch messages, producing an <a href="#Arrow.Table"><code>Arrow.Table</code></a> on each iteration.</p><p>By iterating <a href="#Arrow.Table"><code>Arrow.Table</code></a>, <code>Arrow.Stream</code> satisfies the <code>Tables.partitions</code> interface, and as such can be passed to Tables.jl-compatible sink functions.</p><p>This allows iterating over extremely large &quot;arrow tables&quot; in chunks represented as record batches.</p><p>Supports the <code>convert</code> keyword argument which controls whether certain arrow primitive types will be lazily converted to more friendly Julia defaults; by default, <code>convert=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/table.jl#LL22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.Struct" href="#Arrow.Struct"><code>Arrow.Struct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.Struct</code></pre><p>An <code>ArrowVector</code> where each element is a &quot;struct&quot; of some kind with ordered, named fields, like a <code>NamedTuple{names, types}</code> or regular julia <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/struct.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.Table" href="#Arrow.Table"><code>Arrow.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.Table(io::IO; convert::Bool=true)
Arrow.Table(file::String; convert::Bool=true)
Arrow.Table(bytes::Vector{UInt8}, pos=1, len=nothing; convert::Bool=true)</code></pre><p>Read an arrow formatted table, from:</p><ul><li><code>io</code>, bytes will be read all at once via <code>read(io)</code></li><li><code>file</code>, bytes will be read via <code>Mmap.mmap(file)</code></li><li><code>bytes</code>, a byte vector directly, optionally allowing specifying the starting byte position <code>pos</code> and <code>len</code></li></ul><p>Returns a <code>Arrow.Table</code> object that allows column access via <code>table.col1</code>, <code>table[:col1]</code>, or <code>table[1]</code>.</p><p>NOTE: the columns in an <code>Arrow.Table</code> are views into the original arrow memory, and hence are not easily modifiable (with e.g. <code>push!</code>, <code>append!</code>, etc.). To mutate arrow columns, call <code>copy(x)</code> to materialize the arrow data as a normal Julia array.</p><p><code>Arrow.Table</code> also satisfies the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface, and so can easily be materialied via any supporting sink function: e.g. <code>DataFrame(Arrow.Table(file))</code>, <code>SQLite.load!(db, &quot;table&quot;, Arrow.Table(file))</code>, etc.</p><p>Supports the <code>convert</code> keyword argument which controls whether certain arrow primitive types will be lazily converted to more friendly Julia defaults; by default, <code>convert=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/table.jl#LL157-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.ToTimestamp" href="#Arrow.ToTimestamp"><code>Arrow.ToTimestamp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.ToTimestamp(x::AbstractVector{ZonedDateTime})</code></pre><p>Wrapper array that provides a more efficient encoding of <code>ZonedDateTime</code> elements to the arrow format. In the arrow format, timestamp columns with timezone information are encoded as the arrow equivalent of a Julia type parameter, meaning an entire column <em>should</em> have elements all with the same timezone. If a <code>ZonedDateTime</code> column is passed to <code>Arrow.write</code>, for correctness, it must scan each element to check each timezone. <code>Arrow.ToTimestamp</code> provides a &quot;bypass&quot; of this process by encoding the timezone of the first element of the <code>AbstractVector{ZonedDateTime}</code>, which in turn allows <code>Arrow.write</code> to avoid costly checking/conversion and can encode the <code>ZonedDateTime</code> as <code>Arrow.Timestamp</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/eltypes.jl#LL307-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.ValidityBitmap" href="#Arrow.ValidityBitmap"><code>Arrow.ValidityBitmap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Arrow.ValidityBitmap</code></pre><p>A bit-packed array type where each bit corresponds to an element in an <a href="#Arrow.ArrowVector"><code>ArrowVector</code></a>, indicating whether that element is &quot;valid&quot; (bit == 1), or not (bit == 0). Used to indicate element missingness (whether it&#39;s null).</p><p>If the null count of an array is zero, the <code>ValidityBitmap</code> will be &quot;empty&quot; and all elements are treated as &quot;valid&quot;/non-null.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/arraytypes/arraytypes.jl#LL109-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.append" href="#Arrow.append"><code>Arrow.append</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Arrow.append(io::IO, tbl)
Arrow.append(file::String, tbl)
tbl |&gt; Arrow.append(file)</code></pre><p>Append any <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>-compatible <code>tbl</code> to an existing arrow formatted file or IO. The existing arrow data must be in IPC stream format. Note that appending to the &quot;feather formatted file&quot; is <em>not</em> allowed, as this file format doesn&#39;t support appending. That means files written like <code>Arrow.write(filename::String, tbl)</code> <em>cannot</em> be appended to; instead, you should write like <code>Arrow.write(filename::String, tbl; file=false)</code>.</p><p>When an IO object is provided to be written on to, it must support seeking. For example, a file opened in <code>r+</code> mode or an <code>IOBuffer</code> that is readable, writable and seekable can be appended to, but not a network stream.</p><p>Multiple record batches will be written based on the number of <code>Tables.partitions(tbl)</code> that are provided; by default, this is just one for a given table, but some table sources support automatic partitioning. Note you can turn multiple table objects into partitions by doing <code>Tables.partitioner([tbl1, tbl2, ...])</code>, but note that each table must have the exact same <code>Tables.Schema</code>.</p><p>By default, <code>Arrow.append</code> will use multiple threads to write multiple record batches simultaneously (e.g. if julia is started with <code>julia -t 8</code> or the <code>JULIA_NUM_THREADS</code> environment variable is set).</p><p>Supported keyword arguments to <code>Arrow.append</code> include:</p><ul><li><code>alignment::Int=8</code>: specify the number of bytes to align buffers to when written in messages; strongly recommended to only use alignment values of 8 or 64 for modern memory cache line optimization</li><li><code>dictencode::Bool=false</code>: whether all columns should use dictionary encoding when being written; to dict encode specific columns, wrap the column/array in <code>Arrow.DictEncode(col)</code></li><li><code>dictencodenested::Bool=false</code>: whether nested data type columns should also dict encode nested arrays/buffers; other language implementations <a href="https://arrow.apache.org/docs/status.html">may not support this</a></li><li><code>denseunions::Bool=true</code>: whether Julia <code>Vector{&lt;:Union}</code> arrays should be written using the dense union layout; passing <code>false</code> will result in the sparse union layout</li><li><code>largelists::Bool=false</code>: causes list column types to be written with Int64 offset arrays; mainly for testing purposes; by default, Int64 offsets will be used only if needed</li><li><code>maxdepth::Int=6</code>: deepest allowed nested serialization level; this is provided by default to prevent accidental infinite recursion with mutually recursive data structures</li><li><code>ntasks::Int</code>: number of concurrent threaded tasks to allow while writing input partitions out as arrow record batches; default is no limit; to disable multithreaded writing, pass <code>ntasks=1</code></li><li><code>convert::Bool</code>: whether certain arrow primitive types in the schema of <code>file</code> should be converted to Julia defaults for matching them to the schema of <code>tbl</code>; by default, <code>convert=true</code>.</li><li><code>file::Bool</code>: applicable when an <code>IO</code> is provided, whether it is a file; by default <code>file=false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/append.jl#LL1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.arrowtype" href="#Arrow.arrowtype"><code>Arrow.arrowtype</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a FlatBuffers.Builder and a Julia column or column eltype, Write the field.type flatbuffer definition of the eltype</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/eltypes.jl#LL27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.getmetadata" href="#Arrow.getmetadata"><code>Arrow.getmetadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Arrow.getmetadata(x) =&gt; Dict{String, String}</code></pre><p>Retrieve any metadata (as a <code>Dict{String, String}</code>) attached to <code>x</code>.</p><p>Metadata may be attached to any object via <a href="#Arrow.setmetadata!-Tuple{Any, Dict{String, String}}"><code>Arrow.setmetadata!</code></a>, or deserialized via the arrow format directly (the format allows attaching metadata to table, column, and other objects).</p><p>Note that this function&#39;s return value directly aliases <code>x</code>&#39;s attached metadata (i.e. is not a copy of the underlying storage). Any method author that overloads this function should preserve this behavior so that downstream callers can rely on this behavior in generic code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/write.jl#LL34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.juliaeltype" href="#Arrow.juliaeltype"><code>Arrow.juliaeltype</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a flatbuffers metadata type definition (a Field instance from Schema.fbs), translate to the appropriate Julia storage eltype</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/eltypes.jl#LL17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.setmetadata!-Tuple{Any, Dict{String, String}}" href="#Arrow.setmetadata!-Tuple{Any, Dict{String, String}}"><code>Arrow.setmetadata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Arrow.setmetadata!(x, metadata::Dict{String, String})</code></pre><p>Set the metadata for any object, provided as a <code>Dict{String, String}</code>. Metadata attached to a table or column will be serialized when written as a stream or file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/write.jl#LL20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arrow.write" href="#Arrow.write"><code>Arrow.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Arrow.write(io::IO, tbl)
Arrow.write(file::String, tbl)
tbl |&gt; Arrow.write(io_or_file)</code></pre><p>Write any <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>-compatible <code>tbl</code> out as arrow formatted data. Providing an <code>io::IO</code> argument will cause the data to be written to it in the <a href="https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format">&quot;streaming&quot; format</a>, unless <code>file=true</code> keyword argument is passed. Providing a <code>file::String</code> argument will result in the <a href="https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format">&quot;file&quot; format</a> being written.</p><p>Multiple record batches will be written based on the number of <code>Tables.partitions(tbl)</code> that are provided; by default, this is just one for a given table, but some table sources support automatic partitioning. Note you can turn multiple table objects into partitions by doing <code>Tables.partitioner([tbl1, tbl2, ...])</code>, but note that each table must have the exact same <code>Tables.Schema</code>.</p><p>By default, <code>Arrow.write</code> will use multiple threads to write multiple record batches simultaneously (e.g. if julia is started with <code>julia -t 8</code> or the <code>JULIA_NUM_THREADS</code> environment variable is set).</p><p>Supported keyword arguments to <code>Arrow.write</code> include:</p><ul><li><code>compress</code>: possible values include <code>:lz4</code>, <code>:zstd</code>, or your own initialized <code>LZ4FrameCompressor</code> or <code>ZstdCompressor</code> objects; will cause all buffers in each record batch to use the respective compression encoding</li><li><code>alignment::Int=8</code>: specify the number of bytes to align buffers to when written in messages; strongly recommended to only use alignment values of 8 or 64 for modern memory cache line optimization</li><li><code>dictencode::Bool=false</code>: whether all columns should use dictionary encoding when being written; to dict encode specific columns, wrap the column/array in <code>Arrow.DictEncode(col)</code></li><li><code>dictencodenested::Bool=false</code>: whether nested data type columns should also dict encode nested arrays/buffers; other language implementations <a href="https://arrow.apache.org/docs/status.html">may not support this</a></li><li><code>denseunions::Bool=true</code>: whether Julia <code>Vector{&lt;:Union}</code> arrays should be written using the dense union layout; passing <code>false</code> will result in the sparse union layout</li><li><code>largelists::Bool=false</code>: causes list column types to be written with Int64 offset arrays; mainly for testing purposes; by default, Int64 offsets will be used only if needed</li><li><code>maxdepth::Int=6</code>: deepest allowed nested serialization level; this is provided by default to prevent accidental infinite recursion with mutually recursive data structures</li><li><code>ntasks::Int</code>: number of concurrent threaded tasks to allow while writing input partitions out as arrow record batches; default is no limit; to disable multithreaded writing, pass <code>ntasks=1</code></li><li><code>file::Bool=false</code>: if a an <code>io</code> argument is being written to, passing <code>file=true</code> will cause the arrow file format to be written instead of just IPC streaming</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Arrow.jl/blob/48292d7937c0bbfa4bd2c7591c8caa2678b78664/src/write.jl#LL52-L82">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« User Manual</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 May 2021 16:32">Monday 31 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
